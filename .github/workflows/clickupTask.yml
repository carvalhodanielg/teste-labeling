name: Create ClickUp task on PR

on:
  pull_request:
    branches:
      - main # ajuste conforme sua branch alvo
    types:
      - closed

permissions:
  pull-requests: read
  contents: read

jobs:
  create-clickup-task:
    runs-on: ubuntu-latest
    steps:
      - name: Preflight - validar segredos
        run: |
          test -n "${{ secrets.CLICKUP_API_TOKEN }}" || { echo "CLICKUP_API_TOKEN não configurado"; exit 1; }
          test -n "${{ secrets.CLICKUP_FOLDER_ID }}" || { echo "CLICKUP_FOLDER_ID não configurado"; exit 1; }

      - name: Create ClickUp task from merged PR
        uses: actions/github-script@v7
        env:
          CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
          CLICKUP_FOLDER_ID: ${{ secrets.CLICKUP_FOLDER_ID }}
          CLICKUP_USER_MAP: ${{ secrets.CLICKUP_USER_MAP }}
          CLICKUP_FALLBACK_ASSIGNEE_ID: ${{ secrets.CLICKUP_FALLBACK_ASSIGNEE_ID }}
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) { core.setFailed('Evento não contém pull_request.'); return; }

            // Verificar se o PR foi mergeado (não apenas fechado)
            if (!pr.merged) {
              core.info('PR foi fechado mas não mergeado. Ignorando criação de task.');
              return;
            }

            const token = process.env.CLICKUP_API_TOKEN;
            const folderId = process.env.CLICKUP_FOLDER_ID;

            if (!token) { core.setFailed('CLICKUP_API_TOKEN não configurado.'); return; }
            if (!folderId) { core.setFailed('CLICKUP_FOLDER_ID não configurado.'); return; }

            // 1) Buscar folder para obter listas
            const folderUrl = `https://api.clickup.com/api/v2/folder/${encodeURIComponent(folderId)}`;
            const folderRes = await fetch(folderUrl, {
              method: 'GET',
              headers: {
                'Authorization': token, // ClickUp usa token direto, sem "Bearer"
                'accept': 'application/json'
              }
            });

            const folderText = await folderRes.text();
            let folderData;
            try { folderData = JSON.parse(folderText); } catch { folderData = { raw: folderText }; }

            if (!folderRes.ok) {
              core.setFailed(`Falha ao buscar folder do ClickUp: ${folderRes.status} ${folderRes.statusText} - ${folderText}`);
              return;
            }

            const lists = Array.isArray(folderData.lists) ? folderData.lists : [];
            if (lists.length === 0) { core.setFailed('Folder não contém listas.'); return; }

            // 2) Selecionar a lista "atual": start_date <= now <= due_date
            const now = Date.now();
            const isFiniteMs = v => Number.isFinite(v) && v > 0;

            const candidates = lists
              .map(l => {
                const sd = Number(l.start_date);
                const dd = Number(l.due_date);
                return { ...l, _sd: sd, _dd: dd };
              })
              .filter(l => isFiniteMs(l._sd) && isFiniteMs(l._dd) && l._sd <= now && now <= l._dd);

            // Se houver múltiplas, usa a com maior orderindex
            let chosen;
            if (candidates.length > 0) {
              candidates.sort((a, b) => (b.orderindex || 0) - (a.orderindex || 0));
              chosen = candidates[0];
            } else {
              core.setFailed('Nenhuma lista atual encontrada (now fora do intervalo start_date..due_date).');
              return;
              // Caso prefira fallback:
              // const fallbackSorted = [...lists].sort((a,b)=>(b.orderindex||0)-(a.orderindex||0));
              // chosen = fallbackSorted[0];
              // core.warning(`Sem lista atual; usando fallback: ${chosen.name} (${chosen.id})`);
            }

            const listId = chosen.id;
            core.info(`Usando lista atual: ${chosen.name} (ID: ${listId}) [start=${chosen.start_date}, due=${chosen.due_date}]`);

            // 3) Dados do PR
            const title = `[UI] [TESTES - #${pr.number}] - ${pr.title || 'Sem título'}`;
            const description = pr.body || '';

            // 4) Coletar revisores
            const reviewers = new Set((pr.requested_reviewers || []).map(u => u.login));
            if (context.payload.requested_reviewer?.login) reviewers.add(context.payload.requested_reviewer.login);

            // 5) Mapear revisores para IDs do ClickUp
            let userMap = {};
            try { userMap = JSON.parse(process.env.CLICKUP_USER_MAP || '{}'); }
            catch { core.warning('CLICKUP_USER_MAP inválido; usando mapa vazio.'); userMap = {}; }

            const mappedAssignees = Array.from(reviewers)
              .map(login => userMap[login])
              .filter(v => v !== undefined && v !== null)
              .map(v => Number(v))
              .filter(Number.isFinite);

            const fallback = Number(process.env.CLICKUP_FALLBACK_ASSIGNEE_ID);
            if (mappedAssignees.length === 0 && Number.isFinite(fallback)) mappedAssignees.push(fallback);

            // 6) Criar task
            const payload = {
              assignees: mappedAssignees.length ? mappedAssignees : undefined,
              tags: ['testes manuais'],
              name: title,
              description
            };

            const taskUrl = `https://api.clickup.com/api/v2/list/${encodeURIComponent(listId)}/task`;
            const taskRes = await fetch(taskUrl, {
              method: 'POST',
              headers: {
                'Authorization': token,
                'accept': 'application/json',
                'content-type': 'application/json'
              },
              body: JSON.stringify(payload)
            });

            const taskText = await taskRes.text();
            let taskData; try { taskData = JSON.parse(taskText); } catch { taskData = { raw: taskText }; }

            if (!taskRes.ok) {
              core.setFailed(`Falha ao criar task no ClickUp: ${taskRes.status} ${taskRes.statusText} - ${taskText}`);
              return;
            }

            core.info(`Task criada no ClickUp. ID: ${taskData?.id || 'desconhecido'}`);
            core.setOutput('clickup_task_id', taskData?.id || '');
